package handlers

import (
	"context"
	"crypto/sha256"
	"encoding/hex"
	"encoding/json"
	"fmt"
	"net/http"
	"strings"
	"time"

	"berkut-scc/core/docs"
	"berkut-scc/core/store"
)

func (h *ReportsHandler) ExportAuditPackage(w http.ResponseWriter, r *http.Request) {
	user, roles, _, _, err := h.currentUserWithAccess(r)
	if err != nil || user == nil {
		http.Error(w, "unauthorized", http.StatusUnauthorized)
		return
	}
	from, err := parseDateStrict(strings.TrimSpace(r.URL.Query().Get("period_from")))
	if err != nil {
		http.Error(w, localized(preferredLang(r), "reports.error.invalidPeriod"), http.StatusBadRequest)
		return
	}
	to, err := parseDateStrict(strings.TrimSpace(r.URL.Query().Get("period_to")))
	if err != nil {
		http.Error(w, localized(preferredLang(r), "reports.error.invalidPeriod"), http.StatusBadRequest)
		return
	}
	limit := configInt(map[string]any{"limit": strings.TrimSpace(r.URL.Query().Get("limit"))}, "limit", 300)
	if limit <= 0 || limit > 2000 {
		limit = 300
	}
	format := strings.ToLower(strings.TrimSpace(r.URL.Query().Get("format")))
	if format == "" {
		format = "md"
	}

	md, sections := h.buildAuditPackageMarkdown(r.Context(), user, roles, from, to, limit)
	sum := sha256.Sum256([]byte(md))
	hash := hex.EncodeToString(sum[:])
	filename := fmt.Sprintf("audit_package_%s", time.Now().UTC().Format("20060102_150405"))

	switch format {
	case "json":
		payload := map[string]any{
			"generated_at": time.Now().UTC().Format(time.RFC3339),
			"generated_by": user.Username,
			"period":       formatPeriod(from, to),
			"sha256":       hash,
			"sections":     sections,
		}
		data, _ := json.MarshalIndent(payload, "", "  ")
		w.Header().Set("Content-Type", "application/json; charset=utf-8")
		w.Header().Set("Content-Disposition", fmt.Sprintf("attachment; filename=%s.json", filename))
		w.Header().Set("X-Berkut-Export-SHA256", hash)
		w.WriteHeader(http.StatusOK)
		_, _ = w.Write(data)
	case docs.FormatPDF, docs.FormatDocx:
		data, ct, err := h.svc.ConvertMarkdown(r.Context(), format, []byte(md), "")
		if err != nil {
			http.Error(w, localized(preferredLang(r), "reports.error.exportConverterMissing"), http.StatusBadRequest)
			return
		}
		w.Header().Set("Content-Type", ct)
		w.Header().Set("Content-Disposition", fmt.Sprintf("attachment; filename=%s.%s", filename, format))
		w.Header().Set("X-Berkut-Export-SHA256", hash)
		w.WriteHeader(http.StatusOK)
		_, _ = w.Write(data)
	default:
		w.Header().Set("Content-Type", "text/markdown; charset=utf-8")
		w.Header().Set("Content-Disposition", fmt.Sprintf("attachment; filename=%s.md", filename))
		w.Header().Set("X-Berkut-Export-SHA256", hash)
		w.WriteHeader(http.StatusOK)
		_, _ = w.Write([]byte(md))
	}
	h.log(r.Context(), user.Username, "reports.audit_package.export", "format="+format+" sha256="+hash)
}

func (h *ReportsHandler) buildAuditPackageMarkdown(ctx context.Context, user *store.User, roles []string, from, to *time.Time, limit int) (string, []map[string]any) {
	now := time.Now().UTC()
	var b strings.Builder
	sections := make([]map[string]any, 0, 3)
	b.WriteString("# Audit package\n\n")
	b.WriteString(fmt.Sprintf("- Generated at: %s\n", now.Format("2006-01-02 15:04:05 UTC")))
	b.WriteString(fmt.Sprintf("- Generated by: %s\n", user.Username))
	if from != nil || to != nil {
		b.WriteString(fmt.Sprintf("- Period: %s\n", formatPeriod(from, to)))
	}
	b.WriteString("\n")

	accessRows, accessDenied := h.auditPackageAccessSection(ctx, roles, from, to, limit)
	sections = append(sections, map[string]any{"key": "access", "denied": accessDenied, "count": len(accessRows)})
	b.WriteString("## Access to resources\n\n")
	if accessDenied {
		b.WriteString("_No access._\n\n")
	} else if len(accessRows) == 0 {
		b.WriteString("_No access events for selected period._\n\n")
	} else {
		b.WriteString("| Time | User | Action | Details |\n|---|---|---|---|\n")
		for _, row := range accessRows {
			b.WriteString(fmt.Sprintf("| %s | %s | %s | %s |\n",
				row.CreatedAt.UTC().Format("2006-01-02 15:04"),
				escapePipes(row.Username),
				escapePipes(row.Action),
				escapePipes(truncateText(row.Details, 120)),
			))
		}
		b.WriteString("\n")
	}

	changeRows, changeDenied := h.auditPackageCriticalChangesSection(ctx, roles, from, to, limit)
	sections = append(sections, map[string]any{"key": "critical_changes", "denied": changeDenied, "count": len(changeRows)})
	b.WriteString("## Critical changes\n\n")
	if changeDenied {
		b.WriteString("_No access._\n\n")
	} else if len(changeRows) == 0 {
		b.WriteString("_No critical changes for selected period._\n\n")
	} else {
		b.WriteString("| Time | User | Action | Details |\n|---|---|---|---|\n")
		for _, row := range changeRows {
			b.WriteString(fmt.Sprintf("| %s | %s | %s | %s |\n",
				row.CreatedAt.UTC().Format("2006-01-02 15:04"),
				escapePipes(row.Username),
				escapePipes(row.Action),
				escapePipes(truncateText(row.Details, 120)),
			))
		}
		b.WriteString("\n")
	}

	incRows, incDenied := h.auditPackageIncidentsSection(ctx, roles, from, to, limit)
	sections = append(sections, map[string]any{"key": "incidents", "denied": incDenied, "count": len(incRows)})
	b.WriteString("## Incidents and SLA\n\n")
	if incDenied {
		b.WriteString("_No access._\n\n")
	} else if len(incRows) == 0 {
		b.WriteString("_No incidents for selected period._\n\n")
	} else {
		b.WriteString("| Incident | Severity | Status | Owner | SLA |\n|---|---|---|---|---|\n")
		for _, item := range incRows {
			b.WriteString(fmt.Sprintf("| %s | %s | %s | %d | %s |\n",
				escapePipes(item.RegNo),
				escapePipes(item.Severity),
				escapePipes(item.Status),
				item.OwnerUserID,
				escapePipes(auditSLAState(item)),
			))
		}
		b.WriteString("\n")
	}
	return strings.TrimSpace(b.String()) + "\n", sections
}

func (h *ReportsHandler) auditPackageAccessSection(ctx context.Context, roles []string, from, to *time.Time, limit int) ([]store.AuditRecord, bool) {
	if !h.policy.Allowed(roles, "logs.view") || h.audits == nil {
		return nil, true
	}
	since := time.Now().UTC().Add(-30 * 24 * time.Hour)
	if from != nil {
		since = *from
	}
	rows, err := h.audits.ListFiltered(ctx, since, limit*4)
	if err != nil {
		return nil, false
	}
	out := make([]store.AuditRecord, 0, limit)
	for _, row := range rows {
		if to != nil && row.CreatedAt.After(to.Add(24*time.Hour)) {
			continue
		}
		action := strings.ToLower(strings.TrimSpace(row.Action))
		if strings.Contains(action, "doc.") || strings.Contains(action, "report.") {
			out = append(out, row)
		}
		if len(out) >= limit {
			break
		}
	}
	return out, false
}

func (h *ReportsHandler) auditPackageCriticalChangesSection(ctx context.Context, roles []string, from, to *time.Time, limit int) ([]store.AuditRecord, bool) {
	if !h.policy.Allowed(roles, "logs.view") || h.audits == nil {
		return nil, true
	}
	since := time.Now().UTC().Add(-30 * 24 * time.Hour)
	if from != nil {
		since = *from
	}
	rows, err := h.audits.ListFiltered(ctx, since, limit*6)
	if err != nil {
		return nil, false
	}
	criticalWords := []string{"delete", "remove", "restore", "settings", "acl", "create", "update", "pause", "resume"}
	out := make([]store.AuditRecord, 0, limit)
	for _, row := range rows {
		if to != nil && row.CreatedAt.After(to.Add(24*time.Hour)) {
			continue
		}
		action := strings.ToLower(strings.TrimSpace(row.Action))
		for _, token := range criticalWords {
			if strings.Contains(action, token) {
				out = append(out, row)
				break
			}
		}
		if len(out) >= limit {
			break
		}
	}
	return out, false
}

func (h *ReportsHandler) auditPackageIncidentsSection(ctx context.Context, roles []string, from, to *time.Time, limit int) ([]store.Incident, bool) {
	if !h.policy.Allowed(roles, "incidents.view") || h.incidents == nil {
		return nil, true
	}
	items, err := h.incidents.ListIncidents(ctx, store.IncidentFilter{Limit: limit * 3})
	if err != nil {
		return nil, false
	}
	out := make([]store.Incident, 0, limit)
	for _, item := range items {
		ts := item.UpdatedAt
		if from != nil && ts.Before(*from) {
			continue
		}
		if to != nil && ts.After(to.Add(24*time.Hour)) {
			continue
		}
		out = append(out, item)
		if len(out) >= limit {
			break
		}
	}
	return out, false
}

func auditSLAState(item store.Incident) string {
	if strings.EqualFold(strings.TrimSpace(item.Status), "closed") {
		return "closed"
	}
	deadlineRaw := strings.TrimSpace(item.Meta.ResolveDeadline)
	if deadlineRaw == "" {
		return "unknown"
	}
	deadline, err := time.Parse(time.RFC3339, deadlineRaw)
	if err != nil {
		deadline, err = time.Parse("2006-01-02T15:04", deadlineRaw)
		if err != nil {
			return "unknown"
		}
	}
	if time.Now().UTC().After(deadline.UTC()) {
		return "breach"
	}
	return "in_time"
}

func truncateText(in string, max int) string {
	v := strings.TrimSpace(in)
	if max <= 0 || len(v) <= max {
		return v
	}
	return strings.TrimSpace(v[:max]) + "..."
}
