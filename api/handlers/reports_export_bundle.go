package handlers

import (
	"context"
	"encoding/json"
	"fmt"
	"net/http"
	"sort"
	"strings"
	"time"

	"berkut-scc/core/store"
)

type exportModuleDef struct {
	Key   string
	Title string
}

var exportModules = []exportModuleDef{
	{Key: "tasks", Title: "Tasks"},
	{Key: "controls", Title: "Controls"},
	{Key: "monitoring", Title: "Monitoring"},
	{Key: "sla", Title: "SLA"},
	{Key: "maintenance", Title: "Maintenance"},
	{Key: "approvals", Title: "Approvals"},
	{Key: "incidents", Title: "Incidents"},
	{Key: "logs", Title: "Audit logs"},
	{Key: "docs", Title: "Documents"},
}

func (h *ReportsHandler) ExportBundle(w http.ResponseWriter, r *http.Request) {
	user, roles, groups, eff, err := h.currentUserWithAccess(r)
	if err != nil || user == nil {
		http.Error(w, "unauthorized", http.StatusUnauthorized)
		return
	}
	from, err := parseDateStrict(strings.TrimSpace(r.URL.Query().Get("period_from")))
	if err != nil {
		http.Error(w, localized(preferredLang(r), "reports.error.invalidPeriod"), http.StatusBadRequest)
		return
	}
	to, err := parseDateStrict(strings.TrimSpace(r.URL.Query().Get("period_to")))
	if err != nil {
		http.Error(w, localized(preferredLang(r), "reports.error.invalidPeriod"), http.StatusBadRequest)
		return
	}
	limit := configInt(map[string]any{"limit": strings.TrimSpace(r.URL.Query().Get("limit"))}, "limit", 100)
	if limit <= 0 {
		limit = 100
	}
	modules := parseExportModules(strings.TrimSpace(r.URL.Query().Get("modules")))
	format := strings.ToLower(strings.TrimSpace(r.URL.Query().Get("format")))
	if format == "" {
		format = "md"
	}

	results := make([]reportSectionResult, 0, len(modules))
	totals := map[string]int{}
	denied := make([]string, 0)
	for _, module := range modules {
		sec := store.ReportSection{
			SectionType: module,
			Title:       moduleTitle(module),
			IsEnabled:   true,
			Config:      map[string]any{"limit": limit},
		}
		var res reportSectionResult
		switch module {
		case "tasks":
			res = h.buildTasksSection(r.Context(), sec, user, roles, groups, from, to, totals)
		case "controls":
			res = h.buildControlsSection(r.Context(), sec, user, roles, totals)
		case "monitoring":
			res = h.buildMonitoringSection(r.Context(), sec, user, roles, from, to, totals)
		case "sla":
			sec.SectionType = "sla_summary"
			if periodType := strings.ToLower(strings.TrimSpace(r.URL.Query().Get("sla_period"))); periodType != "" {
				sec.Config["period_type"] = periodType
			}
			res = h.buildSLASummarySection(r.Context(), sec, user, roles, from, to, totals)
		case "maintenance":
			res = h.buildMaintenanceSection(r.Context(), sec, user, roles, from, to, totals)
		case "approvals":
			res = h.buildApprovalsSection(r.Context(), sec, user, roles, from, to, totals)
		case "incidents":
			res = h.buildIncidentsSection(r.Context(), sec, user, roles, eff, from, to, totals)
		case "logs":
			sec.SectionType = "audit"
			res = h.buildAuditSection(r.Context(), sec, user, roles, from, to, totals)
		case "docs":
			res = h.buildDocsSection(r.Context(), sec, user, roles, from, to, totals)
		default:
			res = reportSectionResult{Section: sec, Error: "unsupported module"}
		}
		if res.Denied {
			denied = append(denied, module)
		}
		results = append(results, res)
	}

	now := time.Now().UTC()
	filenameStamp := now.Format("20060102_150405")
	if format == "json" {
		payload := map[string]any{
			"generated_at": now.Format(time.RFC3339),
			"generated_by": user.Username,
			"period_from":  formatPeriodTime(from),
			"period_to":    formatPeriodTime(to),
			"modules":      modules,
			"denied":       denied,
			"sections":     toExportSectionJSON(results),
		}
		data, _ := json.MarshalIndent(payload, "", "  ")
		w.Header().Set("Content-Type", "application/json; charset=utf-8")
		w.Header().Set("Content-Disposition", fmt.Sprintf("attachment; filename=reports_export_%s.json", filenameStamp))
		w.WriteHeader(http.StatusOK)
		_, _ = w.Write(data)
		h.log(r.Context(), user.Username, "reports.export.bundle", strings.Join(modules, ","))
		return
	}

	var b strings.Builder
	b.WriteString("# Executive export\n\n")
	b.WriteString(fmt.Sprintf("- Generated at: %s\n", now.Format("2006-01-02 15:04:05 UTC")))
	b.WriteString(fmt.Sprintf("- Generated by: %s\n", user.Username))
	if from != nil || to != nil {
		b.WriteString(fmt.Sprintf("- Period: %s\n", formatPeriod(from, to)))
	}
	if len(denied) > 0 {
		sort.Strings(denied)
		b.WriteString(fmt.Sprintf("- Denied modules: %s\n", strings.Join(denied, ", ")))
	}
	b.WriteString("\n")
	for _, res := range results {
		if md := strings.TrimSpace(res.Markdown); md != "" {
			b.WriteString(md)
			b.WriteString("\n\n")
			continue
		}
		if res.Error != "" {
			b.WriteString(fmt.Sprintf("## %s\n\n_Error: %s._\n\n", sectionTitle(res.Section, strings.Title(res.Section.SectionType)), res.Error))
		}
	}
	w.Header().Set("Content-Type", "text/markdown; charset=utf-8")
	w.Header().Set("Content-Disposition", fmt.Sprintf("attachment; filename=reports_export_%s.md", filenameStamp))
	w.WriteHeader(http.StatusOK)
	_, _ = w.Write([]byte(strings.TrimSpace(b.String()) + "\n"))
	h.log(r.Context(), user.Username, "reports.export.bundle", strings.Join(modules, ","))
}

func parseExportModules(raw string) []string {
	if strings.TrimSpace(raw) == "" {
		out := make([]string, 0, len(exportModules))
		for _, mod := range exportModules {
			out = append(out, mod.Key)
		}
		return out
	}
	allowed := map[string]struct{}{}
	for _, mod := range exportModules {
		allowed[mod.Key] = struct{}{}
	}
	seen := map[string]struct{}{}
	out := make([]string, 0, len(exportModules))
	for _, chunk := range strings.Split(raw, ",") {
		key := strings.ToLower(strings.TrimSpace(chunk))
		if key == "" {
			continue
		}
		if _, ok := allowed[key]; !ok {
			continue
		}
		if _, ok := seen[key]; ok {
			continue
		}
		seen[key] = struct{}{}
		out = append(out, key)
	}
	if len(out) > 0 {
		return out
	}
	for _, mod := range exportModules {
		out = append(out, mod.Key)
	}
	return out
}

func moduleTitle(module string) string {
	for _, mod := range exportModules {
		if mod.Key == module {
			return mod.Title
		}
	}
	return strings.Title(module)
}

func toExportSectionJSON(items []reportSectionResult) []map[string]any {
	out := make([]map[string]any, 0, len(items))
	for _, item := range items {
		out = append(out, map[string]any{
			"module":     strings.ToLower(strings.TrimSpace(item.Section.SectionType)),
			"title":      strings.TrimSpace(item.Section.Title),
			"denied":     item.Denied,
			"error":      item.Error,
			"item_count": item.ItemCount,
			"summary":    item.Summary,
			"markdown":   strings.TrimSpace(item.Markdown),
		})
	}
	return out
}

func (h *ReportsHandler) buildApprovalsSection(ctx context.Context, sec store.ReportSection, user *store.User, roles []string, from, to *time.Time, totals map[string]int) reportSectionResult {
	res := reportSectionResult{Section: sec}
	if !h.policy.Allowed(roles, "docs.approval.view") {
		res.Denied = true
		res.Markdown = fmt.Sprintf("## %s\n\n_No access._", sectionTitle(sec, "Approvals"))
		return res
	}
	limit := configInt(sec.Config, "limit", 50)
	approvals, err := h.docs.ListApprovals(ctx, store.ApprovalFilter{})
	if err != nil {
		res.Error = "load failed"
		return res
	}
	type rowData struct {
		Approval store.Approval
		Doc      *store.Document
	}
	rows := make([]rowData, 0, len(approvals))
	for _, ap := range approvals {
		ts := ap.UpdatedAt
		if !withinPeriod(ts, from, to) {
			continue
		}
		doc, err := h.docs.GetDocument(ctx, ap.DocID)
		if err != nil || doc == nil || doc.DeletedAt != nil {
			continue
		}
		docACL, _ := h.docs.GetDocACL(ctx, doc.ID)
		var folderACL []store.ACLRule
		if doc.FolderID != nil {
			folderACL, _ = h.docs.GetFolderACL(ctx, *doc.FolderID)
		}
		if !h.svc.CheckACL(user, roles, doc, docACL, folderACL, "view") {
			continue
		}
		rows = append(rows, rowData{Approval: ap, Doc: doc})
	}
	if len(rows) > limit && limit > 0 {
		rows = rows[:limit]
	}
	statusCounts := map[string]int{}
	for _, row := range rows {
		statusCounts[strings.ToLower(strings.TrimSpace(row.Approval.Status))]++
	}
	res.ItemCount = len(rows)
	res.Summary = map[string]any{"approvals": len(rows)}
	totals["approvals"] += len(rows)
	var b strings.Builder
	b.WriteString(fmt.Sprintf("## %s\n\n", sectionTitle(sec, "Approvals")))
	b.WriteString(fmt.Sprintf("- Total: %d\n", len(rows)))
	for key, count := range statusCounts {
		if key == "" {
			continue
		}
		b.WriteString(fmt.Sprintf("- %s: %d\n", strings.Title(key), count))
	}
	if len(rows) == 0 {
		b.WriteString("\n_No approvals for selected period._\n")
		res.Markdown = b.String()
		return res
	}
	b.WriteString("\n| Approval | Document | Status | Stage | Updated |\n|---|---|---|---:|---|\n")
	for _, row := range rows {
		ap := row.Approval
		doc := row.Doc
		docNo := doc.RegNumber
		if strings.TrimSpace(docNo) == "" {
			docNo = fmt.Sprintf("%d", doc.ID)
		}
		b.WriteString(fmt.Sprintf("| %d | %s (%s) | %s | %d | %s |\n",
			ap.ID,
			escapePipes(docNo),
			escapePipes(doc.Title),
			escapePipes(ap.Status),
			ap.CurrentStage,
			ap.UpdatedAt.UTC().Format("2006-01-02"),
		))
		res.Items = append(res.Items, store.ReportSnapshotItem{
			EntityType: "approval",
			EntityID:   fmt.Sprintf("%d", ap.ID),
			Entity: map[string]any{
				"id":             ap.ID,
				"doc_id":         ap.DocID,
				"doc_reg_number": doc.RegNumber,
				"doc_title":      doc.Title,
				"status":         ap.Status,
				"current_stage":  ap.CurrentStage,
				"updated_at":     ap.UpdatedAt.UTC().Format(time.RFC3339),
			},
		})
	}
	res.Markdown = b.String()
	return res
}

func (h *ReportsHandler) buildMaintenanceSection(ctx context.Context, sec store.ReportSection, user *store.User, roles []string, from, to *time.Time, totals map[string]int) reportSectionResult {
	res := reportSectionResult{Section: sec}
	if !h.policy.Allowed(roles, "monitoring.maintenance.view") {
		res.Denied = true
		res.Markdown = fmt.Sprintf("## %s\n\n_No access._", sectionTitle(sec, "Maintenance"))
		return res
	}
	if h.monitoring == nil {
		res.Error = "monitoring unavailable"
		return res
	}
	limit := configInt(sec.Config, "limit", 50)
	items, err := h.monitoring.ListMaintenance(ctx, store.MaintenanceFilter{})
	if err != nil {
		res.Error = "load failed"
		return res
	}
	monitorNames := map[int64]string{}
	monitors, _ := h.monitoring.ListMonitors(ctx, store.MonitorFilter{})
	for _, mon := range monitors {
		monitorNames[mon.ID] = mon.Name
	}
	rows := make([]store.MonitorMaintenance, 0, len(items))
	for _, item := range items {
		if !maintenanceInPeriod(item, from, to) {
			continue
		}
		rows = append(rows, item)
	}
	if len(rows) > limit && limit > 0 {
		rows = rows[:limit]
	}
	active := 0
	recurring := 0
	for _, row := range rows {
		if row.IsActive {
			active++
		}
		if row.IsRecurring {
			recurring++
		}
	}
	res.ItemCount = len(rows)
	res.Summary = map[string]any{
		"maintenance":           len(rows),
		"maintenance_active":    active,
		"maintenance_recurring": recurring,
	}
	totals["maintenance"] += len(rows)
	var b strings.Builder
	b.WriteString(fmt.Sprintf("## %s\n\n", sectionTitle(sec, "Maintenance")))
	b.WriteString(fmt.Sprintf("- Total windows: %d\n", len(rows)))
	b.WriteString(fmt.Sprintf("- Active: %d\n", active))
	b.WriteString(fmt.Sprintf("- Recurring: %d\n", recurring))
	if len(rows) == 0 {
		b.WriteString("\n_No maintenance windows for selected period._\n")
		res.Markdown = b.String()
		return res
	}
	b.WriteString("\n| Name | Scope | Window | Strategy | Active |\n|---|---|---|---|---|\n")
	for _, item := range rows {
		scope := maintenanceScopeLabel(item, monitorNames)
		b.WriteString(fmt.Sprintf("| %s | %s | %s - %s | %s | %s |\n",
			escapePipes(item.Name),
			escapePipes(scope),
			item.StartsAt.UTC().Format("2006-01-02 15:04"),
			item.EndsAt.UTC().Format("2006-01-02 15:04"),
			escapePipes(item.Strategy),
			boolWord(item.IsActive),
		))
		res.Items = append(res.Items, store.ReportSnapshotItem{
			EntityType: "maintenance",
			EntityID:   fmt.Sprintf("%d", item.ID),
			Entity: map[string]any{
				"id":           item.ID,
				"name":         item.Name,
				"starts_at":    item.StartsAt.UTC().Format(time.RFC3339),
				"ends_at":      item.EndsAt.UTC().Format(time.RFC3339),
				"strategy":     item.Strategy,
				"is_active":    item.IsActive,
				"is_recurring": item.IsRecurring,
				"monitor_id":   item.MonitorID,
				"monitor_ids":  item.MonitorIDs,
				"tags":         item.Tags,
			},
		})
	}
	res.Markdown = b.String()
	return res
}

func maintenanceInPeriod(item store.MonitorMaintenance, from, to *time.Time) bool {
	if from == nil && to == nil {
		return true
	}
	start := item.StartsAt.UTC()
	end := item.EndsAt.UTC()
	if to != nil && start.After(*to) {
		return false
	}
	if from != nil && end.Before(*from) {
		return false
	}
	return true
}

func maintenanceScopeLabel(item store.MonitorMaintenance, monitorNames map[int64]string) string {
	if len(item.MonitorIDs) > 0 {
		names := make([]string, 0, len(item.MonitorIDs))
		for _, id := range item.MonitorIDs {
			name := monitorNames[id]
			if strings.TrimSpace(name) == "" {
				name = fmt.Sprintf("#%d", id)
			}
			names = append(names, name)
		}
		return strings.Join(names, ", ")
	}
	if item.MonitorID != nil {
		name := monitorNames[*item.MonitorID]
		if strings.TrimSpace(name) == "" {
			return fmt.Sprintf("#%d", *item.MonitorID)
		}
		return name
	}
	if len(item.Tags) > 0 {
		return "tags: " + strings.Join(item.Tags, ", ")
	}
	return "all monitors"
}
